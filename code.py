# -*- coding: utf-8 -*-
"""Venkata Naga Umesh Munagala_PA5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1u2A12U1XQbLGUoWzh4wuH7dWTEMMCorq
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
# Generates a side-by-side visualization of the grayscale image and its corresponding pixel intensity histogram.
def plot_image_and_histogram(image_path, title, histogram_color, save_prefix):
    img = mpimg.imread(image_path)

    # Plotted the  gray image
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 4))
    ax1.imshow(img, cmap='gray')
    ax1.set_title(title)

    # Computed and ploted the histogram
    histogram, bin_edges = np.histogram(img, bins=256, range=(0.0, 255))
    ax2.plot(bin_edges[0:-1], histogram, color=histogram_color, linestyle='-', linewidth=2)
    ax2.set_title(f"{title} Histogram")
    ax2.set_xlabel("Grayscale Value (Intensity)")
    ax2.set_ylabel("Number of Pixels")
    ax2.set_xlim(0, 255)

    # To save the picture
    fig.savefig(f'{save_prefix}_Histogram.jpg')

    # to show the plot
    plt.show()

"""
This function processes an input image using different threshold values,
binarizes the images, and saves them with filenames that reflect the
corresponding thresholds based on the provided image file path and save prefix.
"""
def apply_threshold_and_save_images(image_path, thresholds, save_prefix):
    img = mpimg.imread(image_path)

    for t in thresholds:
        binarization = np.where(img > t, 255, 0)

        # Plotted and saved the binarized image
        fig, ax = plt.subplots()
        ax.imshow(binarization, cmap='gray')
        ax.axis("off")
        fig.savefig(f'{save_prefix}_Binarized_thresh_{t}.jpg')

        # to show the plot
        plt.show()

def otsu(img):
    # Computed the histogram
    histogram, bin_edges = np.histogram(img, bins=256, range=(0.0, 255))

    # Otsu algorithm
    num_pixels = img.shape[0] * img.shape[1]
    mean_coeff = 1.0 / num_pixels

    # Calculated and probabilities and means
    probabilities = [np.sum(histogram[:t]) * mean_coeff for t in range(256)]
    means = [np.dot(np.arange(t), histogram[:t]) / np.sum(histogram[:t]) if np.sum(histogram[:t]) > 0 else 0 for t in range(256)]

    # Calculated the variances
    variances = [probabilities[t] * (1 - probabilities[t]) * (means[t] - means[-1]) ** 2 for t in range(256)]

    # Find threshold with the largest variance
    threshold_final = np.argmax(variances)

    # Apply Otsu threshold
    otsu_image = np.where(img > threshold_final, 255, 0)

    return otsu_image, threshold_final

#This function utilizes Otsu's thresholding technique on an input image, creates the resultant thresholded image, and saves the outcome.

def apply_otsu_and_save(image_path, save_prefix):
    img = mpimg.imread(image_path)
    otsu_image, otsu_threshold = otsu(img)

    # Plot and save the Otsu thresholded image
    fig, ax = plt.subplots()
    ax.imshow(otsu_image, cmap='gray')
    ax.axis("off")
    fig.savefig(f'{save_prefix}_Otsu_thresh_{otsu_threshold}.jpg')

    # To Show the plot
    plt.show()

# Given the Image 1
plot_image_and_histogram('181018.jpg', 'Image_a', 'blue', 'Image_a')
apply_threshold_and_save_images('181018.jpg', [45, 60, 120], 'Image_a')

# Given the Image 2
plot_image_and_histogram('198004.jpg', 'Image_b', 'orange', 'Image_b')
apply_threshold_and_save_images('198004.jpg', [50, 90, 160], 'Image_b')

# Given the Image 3
plot_image_and_histogram('388016.jpg', 'Image_c', 'green', 'Image_c')
apply_threshold_and_save_images('388016.jpg', [85, 160, 220], 'Image_c')

# Image 1 in Otsu
apply_otsu_and_save('181018.jpg', 'Image_1')

# Image 2 in Otsu
apply_otsu_and_save('198004.jpg', 'Image_2')

# Image 3 in Otsu
apply_otsu_and_save('388016.jpg', 'Image_3')